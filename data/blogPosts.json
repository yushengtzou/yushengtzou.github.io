[
  {
    "id": 1755590057557,
    "title": "探討快速傅立葉轉換（Fast Fourier Transform, FFT）理論與實驗",
    "slug": "fast-fourier-transform-fft",
    "excerpt": "---\r\ntitle: '探討快速傅立葉轉換（Fast Fourier Transform, FFT）理論與實驗'\r\n\r\n---\r\n\r\n# 探討快速傅立葉轉換（Fast Fourier Transform, FFT）理論與實驗\r\n\r\n\r\n# 1. 前言\r\n\r\n理論上來說，離散時間訊號的頻譜 (Spe...",
    "content": "---\r\ntitle: '探討快速傅立葉轉換（Fast Fourier Transform, FFT）理論與實驗'\r\n\r\n---\r\n\r\n# 探討快速傅立葉轉換（Fast Fourier Transform, FFT）理論與實驗\r\n\r\n\r\n# 1. 前言\r\n\r\n理論上來說，離散時間訊號的頻譜 (Spectrum) 可以使用離散時間傅立葉轉換 (Discrete-Time Fourier Transform, DTFT) 得到。但實際上電腦並不存在無限大的記憶體空間，因此我們會使用離散傅立葉轉換 (Discrete Fourier Transform, DFT) 方法，並使用一個稱為快速傅立葉轉換 (Fast Fourier Transform, FFT) 的計算高效演算法用程式計算而得。\r\n\r\n## 1.1 DTFT 初探\r\n\r\n離散時間訊號以 $x[n]$ 表示，$n$ 屬於整數，DTFT 配對定義如下：\r\n\r\n**Forward DTFT:**\r\n\r\n$$\r\nX(e^{j\\omega}) = \\sum_{n=-\\infty}^{\\infty} x[n] e^{-j\\omega n}\r\n$$\r\n\r\n**Inverse DTFT:**\r\n\r\n$$\r\nx[n] = \\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} X(e^{j\\omega}) e^{j\\omega n} \\, d\\omega\r\n$$\r\n\r\n\r\n一般而言，離散時間訊號的 DTFT 頻譜是以 $2π$ 為週期的。在實務上，我們通常假設這個離散訊號是根據取樣定理，從一個頻帶限制在 $[−fs/2,fs/2]$ 的類比訊號取樣而來。經過正規化後，這個頻帶對應到數位角頻率 $[-π, π]$ 的區間。因此，雖然 DTFT 頻譜在整個頻率軸上都存在，但其所有的唯一資訊都集中在 $[-π, π]$ 這個基本週期內，我們通常也只分析這個區間。\r\n\r\n## 1.2 DFT 初探\r\n\r\n假設現在有一個 $N$-point 訊號，並定義 $W_N = e^{-j(\\frac{2\\pi}{N})}$，$W_N^n$ 是多項式 $W^n = 1$ 的根，則 DFT 配對定義如下：\r\n\r\n**DFT (Discrete Fourier Transform)**\r\n\r\n$$X[k] = \\sum_{n=0}^{N-1} x[n]W_N^{kn}, \\quad k = 0, 1, \\dots, N-1$$\r\n\r\n**IDFT (Inverse Discrete Fourier Transform)**\r\n\r\n$$x[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k]W_N^{-kn}, \\quad n = 0, 1, \\dots, N-1$$\r\n\r\n在這裡 $W_N^n$ 是多項式 $W^N = 1$ 的第 $n$ 個根。值得注意的是，使用上面的方程式做計算的話，在乘法的時間複雜度會是 $O(n^2)$，在加法的時間複雜度會是 $O(n(n-1)), i.e., O(n^2    )$。\r\n\r\n\r\n# 2. 理論\r\n\r\nCooley-Tukey 演算法是 FFT 的其中一個重要的演算法，它最主要的原理有兩個：\r\n1. $W_N^2 = W_{N/2}$ (例如：$W_8^2 = W_4$)。\r\n2. 迭代地做分治法 (Divide and Conquer)\r\n\r\n我們已經知道在這裡 $W_N^n$ 是多項式 $W^N = 1$ 的第 $n$ 個根，如果 $N = 8$：\r\n\r\n<div style=\"text-align: center;\">\r\n<img src=\"https://hackmd.io/_uploads/S1fBqsTOle.png\" width=50%>\r\n</div>\r\n\r\n## 2.1 FFT 演算法於時間域減退抽樣 (Decimation-in-time)\r\n\r\n\r\n一般來說，\r\n\r\n$$\r\nX[k] = \\sum_{n \\,\\text{even}} x[n] W_N^{nk} \\;+\\; \\sum_{n \\,\\text{odd}} x[n] W_N^{nk}\r\n$$\r\n\r\n假設 $N = 8$，我們可以分解 $N$-point DFT 為兩個 $N/2$-point DFT。\r\n\r\n![截圖 2025-08-16 下午3.31.02](https://hackmd.io/_uploads/B1X6726dex.png)\r\n\r\n我們可以進一步分解 $N/2$-point DFT 為兩個 $N/4$-point DFT。\r\n\r\n![截圖 2025-08-16 下午3.44.29](https://hackmd.io/_uploads/By3kD26_ee.png)\r\n\r\n因此，$8$-point DFT 可以用四個 $2$-point DFT 得到。\r\n\r\n![截圖 2025-08-16 下午3.45.21](https://hackmd.io/_uploads/rkRfDnadlg.png)\r\n\r\n最後，每一個 $2$-point DFT 可以用以下的 single-flow graph 實作，而不需要用到乘法：\r\n\r\n<div style=\"text-align: center;\">\r\n<img src=\"https://hackmd.io/_uploads/rkN5d3adgx.png\" width=\"66%\">\r\n</div>\r\n\r\n以下是 $8$-point DFT 於時間域減退抽樣得到的 single-graph。\r\n\r\n![image](https://hackmd.io/_uploads/rJaIF2T_ex.png)\r\n\r\n在 FFT 於時間域減退抽樣的每一個階段，有一個基本的結構叫做蝴蝶計算 (Butterfly computation)\r\n\r\n$$\r\nX_m[p] = X_{m-1}[p] + W_N^r X_{m-1}[q]\r\n$$\r\n\r\n$$\r\nX_m[q] = X_{m-1}[p] - W_N^r X_{m-1}[q]\r\n$$\r\n\r\n\r\n以 flow graph 來表示蝴蝶計算 (Butterfly computation)，如下：\r\n\r\n<div style=\"text-align: center;\">\r\n  <img src=\"https://hackmd.io/_uploads/S17_c2puex.png\" width=\"66%\">\r\n</div>\r\n\r\n它又可以簡化為如下：\r\n\r\n<div style=\"text-align: center;\">\r\n<img src=\"https://hackmd.io/_uploads/Syf09haugl.png\" width=\"66%\">\r\n</div>\r\n\r\n\r\n\r\n## 2.2 FFT 演算法於頻率域減退抽樣 (Decimation-in-frequency)\r\n\r\n\r\n\r\n# 3. 實驗\r\n\r\n我們將使用 MATLAB 並使用 FFT 做影像訊號的初步實驗。\r\n\r\n（待補）\r\n\r\n\r\n# 參考文獻\r\n\r\n[1] 陳祝嵩, 國立臺灣大學資訊工程學系, \"112-2 數位訊號處理概論投影片\", Course Slides, 2024.",
    "date": "2025-08-19T07:54:17.557Z",
    "category": "General",
    "readTime": "2 min read",
    "published": true,
    "author": "Yu-Sheng Tzou",
    "image": null
  },
  {
    "id": 1755589359937,
    "title": "Linux Kernel Suspend_Resume 理論與實驗",
    "slug": "linux-kernel-suspend_resume-",
    "excerpt": "---\r\ntitle: Linux Kernel Suspend/Resume 理論與實驗\r\n\r\n---\r\n\r\n# Linux Kernel Suspend/Resume 理論與實驗\r\n# 目錄\r\n[toc]\r\n\r\n# 1. 理論\r\n\r\n## 1.1 System Sleep States\r\n\r\nL...",
    "content": "---\r\ntitle: Linux Kernel Suspend/Resume 理論與實驗\r\n\r\n---\r\n\r\n# Linux Kernel Suspend/Resume 理論與實驗\r\n# 目錄\r\n[toc]\r\n\r\n# 1. 理論\r\n\r\n## 1.1 System Sleep States\r\n\r\nLinux 核心提供了四種系統睡眠狀態，其中也包含了「休眠 (hibernation)」。本文將逐一介紹這些狀態：\r\n\r\n### 1.1.1 Suspend-to-Idle\r\n\r\n- 這是一種純由軟體實現的輕量級系統休眠模式，也被稱為 S2I 或 S2Idle。相較於「執行期閒置 (runtime idle)」，S2Idle 透過凍結使用者空間 (userspace) 來達成更佳的節能效果。具體而言，系統會暫停計時功能 (timekeeping)、將所有 I/O 裝置切換至低功耗狀態，從而讓處理器能長時間停留在最深的閒置狀態。\r\n- 系統透過「帶內中斷 (in-band interrupt)」從此狀態喚醒。因此，理論上任何能在工作狀態下發出中斷訊號的裝置，都能被設定為 S2Idle 的喚醒來源。\r\n- 此狀態適用於不支援「待命 (Standby)」或「內存暫停 (Suspend-to-RAM)」的平台。\r\n- 總結來說，S2Idle 的喚醒速度最快，但節能效果也最有限。\r\n\r\n### 1.1.2 Standby\r\n\r\n- 此狀態提供中等程度的節能效果，且能迅速恢復至工作狀態。由於運行狀態不會遺失，系統可以從休眠前的中斷點繼續執行。\r\n- 除了執行與 S2Idle 相同的操作（凍結使用者空間、暫停計時功能、將 I/O 裝置設為低功耗）外，進入此狀態時，未使用的 CPU 核心會被離線，所有低階系統功能也會被暫停。因此，相較於 S2Idle，Standby 模式更為省電，但喚醒延遲也相對較長。\r\n- 能夠支援此模式的裝置種類比 S2Idle 來得少。\r\n\r\n### 1.1.3 Suspend-to-RAM\r\n\r\n- 此狀態能提供優異的節能效果，因為除了記憶體之外，系統內所有元件都會進入低功耗狀態。唯一的例外是記憶體，它會進入「自我刷新模式 (self-refresh mode)」以保存其內容。所有在「待命 (Standby)」模式下執行的步驟，在此模式中也會被執行。\r\n- 在基於 ACPI 的系統上，進入此模式的最後一步，是由核心將系統控制權移交給平台韌體（如 BIOS）。接著，韌體會關閉那些不受核心直接控制的低階裝置電源。透過上述步驟，裝置與 CPU 的完整狀態便得以儲存並保留在記憶體中。\r\n- 在基於 ACPI 的系統中，喚醒過程僅需韌體中一小段「啟動程式碼 (boot-strapping code)」即可完成。因此，支援此模式的硬體要求更高，相容的裝置種類也比 S2Idle 和 Standby 更少。\r\n\r\n### 1.1.4 休眠 (Hibernation)\r\n\r\n此狀態（也稱為「硬碟暫停」或 STD）能提供最大程度的節能效果，即使在平台不具備低階系統休眠支援的情況下也能使用。然而，它需要在底層 CPU 架構中，預先存在一段用於恢復系統的低階程式碼。休眠模式與前述幾種系統暫停的變體有著顯著不同。它需要經過三個系統狀態變更才能進入休眠，並需要兩個狀態變更才能恢復。\r\n\r\n過程如下：\r\n\r\n1. 首先，當休眠被觸發時，核心會停止所有系統活動，並建立一個準備寫入「持久性儲存裝置 (persistent storage)」的記憶體快取映像檔。接著，系統會進入一個可以儲存快照的狀態，在映像檔被寫出後，系統最終會進入目標低功耗狀態。在此狀態下，包含記憶體在內的幾乎所有硬體元件都會被斷電，只保留一小部分喚醒裝置的電力。\r\n2. 一旦快取映像檔寫入完成，系統可以選擇進入一個特殊的低功耗狀態（如 ACPI S4），或者直接完全關機。完全關機意味著最低的電力消耗，並讓此機制適用於任何系統。然而，進入特殊的低功G功耗狀態能提供額外的喚醒方式（例如，按下鍵盤或掀開筆記型電腦的上蓋）。\r\n3. 喚醒後，控制權會移交給平台韌體，韌體會執行「開機載入程式 (boot loader)」來啟動一個全新的核心實例（根據系統配置，控制權也可能直接移交給開機載入程式，但無論如何都會啟動一個全新的核心）。這個新的核心實例（稱為「恢復核心」, restore kernel），會到持久性儲存裝置中尋找休眠映像檔。如果找到，便將其載入記憶體。\r\n4. 隨後，系統中的所有活動會再次停止，「恢復核心」會用映像檔的內容覆寫自己，然後跳轉到儲存在映像檔中原始核心（稱為「映像檔核心」, image kernel）裡的一個特殊「跳板區域 (trampoline area)」。這一步驟正是需要特定CPU架構低階程式碼的地方。最後，由「映像檔核心」將系統恢復到休眠前的狀態，並允許使用者空間的程式再次運行。\r\n\r\n當核心配置選項 `CONFIG_HIBERNATION` 被設定時，系統即支援休眠功能。然而，此選項必須在對應的 CPU 架構已包含系統恢復所需的低階程式碼時，才能被啟用。\r\n\r\n## 1.2 System Suspend Code Flows\r\n\r\n\r\n### 1.2.1 `suspend-to-idle` 的暫停執行流程\r\n\r\n![suspend-to-idle (2)](https://hackmd.io/_uploads/HknHuVzvxg.png)\r\n\r\n\r\n為了將系統從工作狀態轉換到 `suspend-to-idle` 睡眠狀態，系統會執行以下步驟：\r\n\r\n1. **調用全系統的暫停通知回呼 (suspend notifiers)**\r\n    - 核心的各個子系統可以註冊回呼函式，這些函式會在系統即將進入暫停狀態以及從暫停狀態恢復完成後被調用。\r\n    - 這使得它們能夠為系統狀態的變更做準備，並在返回工作狀態後進行清理工作。\r\n2. **凍結任務 (Freezing tasks)**\r\n    - 凍結任務的主要目的，是為了避免使用者空間的程式透過直接暴露的 [Memory-mapped I/O (MMIO)](https://en.wikipedia.org/wiki/Memory-mapped_I/O_and_port-mapped_I/O) 區域或 [I/O 暫存器](https://en.wikipedia.org/wiki/Hardware_register)，在無人監管下存取硬體；同時也防止在下個轉換步驟進行中時，使用者空間的程式再次進入核心（這可能引發各種問題）。\r\n    - 所有使用者空間的任務都會被攔截，如同收到信號一般，並被置於「不可中斷睡眠 (uninterruptible sleep)」狀態，直到後續的系統恢復流程結束。\r\n    - 因特定原因而選擇在系統暫停期間被凍結的核心執行緒 (kernel threads) 會隨後被凍結，但它們不會被攔截。相反地，它們被設計為能定期檢查自身是否需要被凍結，並在需要時自行進入不可中斷睡眠狀態。【請注意：核心執行緒可以使用鎖定機制以及核心空間中其他的並行控制方法，來與系統的暫停和恢復進行同步，這種方式遠比凍結任務來得更精確，因此不建議核心執行緒使用凍結的方式。】\r\n3. **暫停裝置並重新設定 [IRQ](https://en.wikipedia.org/wiki/Interrupt_request)**\r\n    - 裝置的暫停過程分為四個階段，分別是 `prepare`（準備）、`suspend`（暫停）、`late suspend`（延後暫停）和 `noirq suspend`（無中斷暫停）。（關於各階段的具體內容，請參考《裝置電源管理基礎》）。\r\n    - 每個裝置都會經歷這四個階段，但通常在物理層面上只會在其中不超過兩個階段被存取。\r\n    - 在 `late suspend` 階段，每個裝置的「執行期電源管理 (Runtime PM)」 API 會被停用；在進入 `noirq suspend` 階段前，高階的「動作型 (action)」中斷處理常式會被禁止調用。\r\n    - 此後，中斷信號雖仍會被處理，但系統僅會向中斷控制器發出確認信號，而不會執行任何在工作狀態下會被觸發的、針對特定裝置的動作（這些動作會被推遲到後續的系統恢復流程中執行，如下文所述）。\r\n    - 與系統喚醒裝置相關的 IRQ 會被「布署 (armed)」，以便當其中之一發出事件信號時，能啟動系統的恢復流程。\r\n4. **凍結排程器時脈 (scheduler tick) 並暫停計時功能 (timekeeping)**\r\n    - 當所有裝置都已暫停後，CPU 會進入閒置循環，並被置於可用的最深度閒置狀態。在此過程中，每個 CPU 都會「凍結」自身的排程器時脈，以確保與該時脈相關的計時器事件在 CPU 被其他中斷源喚醒前不會發生。\r\n    - 最後一個進入閒置狀態的 CPU 同時會停止系統的計時功能，這將（連同其他作用）阻止高精度計時器觸發事件，直到第一個被喚醒的 CPU 重新啟動計時功能為止。這使得所有 CPU 能一次性地在深度閒置狀態下停留相對較長的時間。\r\n    - 從此刻起，CPU 只能被非計時器的硬體中斷喚醒。當中斷發生時，CPU 會返回閒置狀態，除非喚醒它的中斷來自一個已被布署用於系統喚醒的 IRQ，在這種情況下，系統恢復流程便會啟動。\r\n\r\n### 1.2.2 `suspend-to-idle` 的恢復執行流程\r\n\r\n為了將系統從 `suspend-to-idle` 睡眠狀態轉換回工作狀態，系統會執行以下步驟：\r\n\r\n1. **恢復計時功能並解凍排程器時脈**\r\n    - 當其中一個 CPU 被（非計時器的硬體中斷）喚醒時，它會離開在暫停流程最後一步進入的閒置狀態，重新啟動計時功能（除非已被其他更早喚醒的 CPU 啟動），並且該 CPU 上的排程器時脈會被解凍。\r\n    - 如果喚醒該 CPU 的中斷是已被布署用於系統喚醒的，則系統恢復流程開始。\r\n2. **恢復裝置並還原 IRQ 的工作狀態設定**\r\n    - 裝置的恢復過程分為四個階段，分別是 `noirq resume`（無中斷恢復）、`early resume`（早期恢復）、`resume`（恢復）和 `complete`（完成）。（關於各階段的具體內容，請參考《裝置電源管理基礎》）。\r\n    - 每個裝置都會經歷這四個階段，但通常在物理層面上只會在其中不超過兩個階段被存取。\r\n    - 在 `noirq resume` 階段後，IRQ 的工作狀態設定會被還原；在 `early resume` 階段，對於所有支援 Runtime PM 的裝置驅動程式，其 Runtime PM API 會被重新啟用。\r\n3. **解凍任務 (Thawing tasks)**\r\n    - 在先前暫停流程步驟 2 中被凍結的任務會被「解凍」，這意味著它們會從當時進入的不可中斷睡眠狀態中被喚醒，並且使用者空間的任務被允許退出核心。\r\n4. **調用全系統的恢復通知回呼 (resume notifiers)**\r\n    - 此步驟與暫停流程的步驟 1 相對應，調用的是同一組回呼函式，但會傳遞一個不同的「通知類型」參數值給它們。\r\n\r\n### 1.2.3 平台相依 (Platform-dependent) 的暫停執行流程\r\n\r\n為了將系統從工作狀態轉換到平台相依的暫停狀態，系統會執行以下步驟：\r\n\r\n1. **調用全系統的暫停通知回呼**\r\n    - 此步驟與上述 `suspend-to-idle` 暫停流程的步驟 1 相同。\r\n2. **凍結任務**\r\n    - 此步驟與上述 `suspend-to-idle` 暫停流程的步驟 2 相同。\r\n3. **暫停裝置並重新設定 IRQ**\r\n    - 此步驟與上述 `suspend-to-idle` 暫停流程的步驟 3 相對應，但為系統喚醒而布署 IRQ 的操作通常對平台沒有任何影響。\r\n    - 有些平台，當其內部所有 CPU 都處於足夠深的閒置狀態，且所有 I/O 裝置都已置於低功耗狀態時，其自身也能進入一個非常深的低功耗狀態。在這些平台上，`suspend-to-idle` 機制可以非常有效地降低系統功耗。\r\n    - 然而，在其他平台上，要達到同等的功耗降低效果，則需要以平台特定的方式（在平台驅動程式提供的掛鉤 (hooks) 中實現）來關閉如中斷控制器等低階元件。\r\n    - 這通常會阻止「帶內 (in-band)」硬體中斷喚醒系統，系統喚醒必須透過一種特殊的、平台相依的方式來完成。因此，系統喚醒源的設定通常在系統喚醒裝置被暫停時就已開始，並在稍後由平台暫停掛鉤最終完成。\r\n4. **停用非啟動 CPU (non-boot CPUs)**\r\n    - 在某些平台上，前述的暫停掛鉤必須在單一 CPU 的系統配置下運行（特別是，硬體不能被任何與平台暫停掛鉤並行運行的程式碼存取，因為這些掛鉤可能、且經常會陷入 (trap into) 平台韌體以完成暫停轉換）。\r\n    - 為此，系統會使用「CPU 熱插拔 (CPU hotplug)」框架，將除了一個 CPU（即啟動 CPU）之外的所有 CPU 離線（通常，被離線的 CPU 會進入深度閒置狀態）。\r\n    - 這意味著所有任務都會從這些 CPU 上被遷移走，所有 IRQ 也會被重新路由到唯一保持在線的那個 CPU 上。\r\n5. **暫停核心系統元件**\r\n    - 此步驟為核心系統元件接下來可能發生的斷電做準備，並暫停計時功能。\r\n6. **平台特定的電源移除**\r\n    - 此步驟預期會移除系統中所有元件的電源，除了記憶體控制器和 RAM（為了保存其內容）以及一些指定的系統喚醒裝置。\r\n    - 在許多情況下，控制權會被移交給平台韌體，由韌體根據需要完成最終的暫停轉換。\r\n\r\n### 1.2.4 平台相依的恢復執行流程\r\n\r\n為了將系統從平台相依的暫停狀態轉換回工作狀態，系統會執行以下步驟：\r\n\r\n1. **平台特定的系統喚醒**\r\n    - 平台被某個指定的系統喚醒裝置發出的信號喚醒（該信號不一定是帶內硬體中斷），控制權被交還給核心（在核心重獲控制權之前，平台韌體可能需要還原平台的工作組態）。\r\n2. **恢復核心系統元件**\r\n    - 核心系統元件在暫停期間的設定被還原，計時功能被恢復。\r\n3. **重新啟用非啟動 CPU**\r\n    - 在先前暫停流程步驟 4 中被停用的 CPU 會被重新上線，它們在暫停期間的設定也會被還原。\r\n4. **恢復裝置並還原 IRQ 的工作狀態設定**\r\n    - 此步驟與上述 `suspend-to-idle` 恢復流程的步驟 2 相同。\r\n5. **解凍任務**\r\n    - 此步驟與上述 `suspend-to-idle` 恢復流程的步驟 3 相同。\r\n6. **調用全系統的恢復通知回呼**\r\n    - 此步驟與上述 `suspend-to-idle` 恢復流程的步驟 4 相同。\r\n\r\n# 2. 實驗\r\n## 2.1 開發環境\r\n```shell\r\n$ gcc --version\r\ngcc (Ubuntu 14.2.0-19ubuntu2) 14.2.0\r\nCopyright (C) 2024 Free Software Foundation, Inc.\r\nThis is free software; see the source for copying conditions.  There is NO\r\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n```\r\n\r\n\r\n```shell\r\n$ lscpu\r\nArchitecture:             x86_64\r\n  CPU op-mode(s):         32-bit, 64-bit\r\n  Address sizes:          39 bits physical, 48 bits virtual\r\n  Byte Order:             Little Endian\r\nCPU(s):                   20\r\n  On-line CPU(s) list:    0-19\r\nVendor ID:                GenuineIntel\r\n  Model name:             12th Gen Intel(R) Core(TM) i7-12700H\r\n    CPU family:           6\r\n    Model:                154\r\n    Thread(s) per core:   2\r\n    Core(s) per socket:   14\r\n    Socket(s):            1\r\n    Stepping:             3\r\n    CPU(s) scaling MHz:   19%\r\n    CPU max MHz:          4700.0000\r\n    CPU min MHz:          400.0000\r\n    BogoMIPS:             5376.00\r\n    Flags:                fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge m\r\n                          ca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 s\r\n                          s ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc \r\n                          art arch_perfmon pebs bts rep_good nopl xtopology nons\r\n                          top_tsc cpuid aperfmperf tsc_known_freq pni pclmulqdq \r\n                          dtes64 monitor ds_cpl vmx smx est tm2 ssse3 sdbg fma c\r\n                          x16 xtpr pdcm pcid sse4_1 sse4_2 x2apic movbe popcnt t\r\n                          sc_deadline_timer aes xsave avx f16c rdrand lahf_lm ab\r\n                          m 3dnowprefetch cpuid_fault epb ssbd ibrs ibpb stibp i\r\n                          brs_enhanced tpr_shadow flexpriority ept vpid ept_ad f\r\n                          sgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid rd\r\n                          seed adx smap clflushopt clwb intel_pt sha_ni xsaveopt\r\n                           xsavec xgetbv1 xsaves split_lock_detect user_shstk av\r\n                          x_vnni dtherm ida arat pln pts hwp hwp_notify hwp_act_\r\n                          window hwp_epp hwp_pkg_req hfi vnmi umip pku ospke wai\r\n                          tpkg gfni vaes vpclmulqdq rdpid movdiri movdir64b fsrm\r\n                           md_clear serialize arch_lbr ibt flush_l1d arch_capabi\r\n                          lities\r\nVirtualization features:  \r\n  Virtualization:         VT-x\r\nCaches (sum of all):      \r\n  L1d:                    544 KiB (14 instances)\r\n  L1i:                    704 KiB (14 instances)\r\n  L2:                     11.5 MiB (8 instances)\r\n  L3:                     24 MiB (1 instance)\r\nNUMA:                     \r\n  NUMA node(s):           1\r\n  NUMA node0 CPU(s):      0-19\r\nVulnerabilities:          \r\n  Gather data sampling:   Not affected\r\n  Ghostwrite:             Not affected\r\n  Itlb multihit:          Not affected\r\n  L1tf:                   Not affected\r\n  Mds:                    Not affected\r\n  Meltdown:               Not affected\r\n  Mmio stale data:        Not affected\r\n  Reg file data sampling: Mitigation; Clear Register File\r\n  Retbleed:               Not affected\r\n  Spec rstack overflow:   Not affected\r\n  Spec store bypass:      Mitigation; Speculative Store Bypass disabled via prct\r\n                          l\r\n  Spectre v1:             Mitigation; usercopy/swapgs barriers and __user pointe\r\n                          r sanitization\r\n  Spectre v2:             Mitigation; Enhanced / Automatic IBRS; IBPB conditiona\r\n                          l; PBRSB-eIBRS SW sequence; BHI BHI_DIS_S\r\n  Srbds:                  Not affected\r\n  Tsx async abort:        Not affected\r\n\r\n```\r\n\r\n## 2.2 工具介紹\r\n\r\n### pm-graph\r\n它是一套針對 Linux 作業系統的電源管理（Power Management）測試與分析視覺化工具，包含 suspend/resume 與系統開機流程，主要有兩個工具：```sleepgraph``` 與 ```bootgraph```。它會根據 ```ftrace``` 記錄或 ```dmesg log```，製作 suspend/resume 的時間軸圖（Timeline）。\r\n \r\n\r\n\r\n### Perfetto\r\n它是一個針對 Client-side (客戶端) 或嵌入式系統的 Tracing （追蹤）和 Profiling（效能分析）， 由 Google 開發的系統效能分析與視覺化開源工具。\r\n\r\n\r\n## 2.3 安裝與設定\r\npython 安裝步驟\r\n\r\n```shell\r\nsudo apt-get install python3 python3-requests linux-tools-common\r\n```\r\n安裝步驟\r\n\r\n```shell\r\ngit clone http://github.com/intel/pm-graph.git\r\ncd pm-graph\r\nsudo make install\r\n```\r\n\r\nKernel 編譯選項（所有核心都需要）：\r\n```shell\r\nCONFIG_DEVMEM=y\r\nCONFIG_PM_DEBUG=y\r\nCONFIG_PM_SLEEP_DEBUG=y\r\nCONFIG_FTRACE=y\r\nCONFIG_FUNCTION_TRACER=y\r\nCONFIG_FUNCTION_GRAPH_TRACER=y\r\nCONFIG_KPROBES=y\r\nCONFIG_KPROBES_ON_FTRACE=y\r\n```\r\n\r\n\r\n\r\n## 2.4 使用方式\r\n\r\n要了解 ```sleepgraph``` 的使用方式，可以在終端機輸入以下指令：\r\n\r\n```shell\r\nsudo sleepgraph -h\r\n```\r\n\r\n程式就會輸出相關的使用指令。\r\n\r\n```shell\r\nSleepGraph v5.13\r\nUsage: sudo sleepgraph <options> <commands>\r\n\r\nDescription:\r\n  This tool is designed to assist kernel and OS developers in optimizing\r\n  their linux stack's suspend/resume time. Using a kernel image built\r\n  with a few extra options enabled, the tool will execute a suspend and\r\n  capture dmesg and ftrace data until resume is complete. This data is\r\n  transformed into a device timeline and an optional callgraph to give\r\n  a detailed view of which devices/subsystems are taking the most\r\n  time in suspend/resume.\r\n\r\n  If no specific command is given, the default behavior is to initiate\r\n  a suspend/resume and capture the dmesg/ftrace output as an html timeline.\r\n\r\n  Generates output files in subdirectory: suspend-yymmdd-HHMMSS\r\n   HTML output:                    <hostname>_<mode>.html\r\n   raw dmesg output:               <hostname>_<mode>_dmesg.txt\r\n   raw ftrace output:              <hostname>_<mode>_ftrace.txt\r\n\r\nOptions:\r\n   -h           Print this help text\r\n   -v           Print the current tool version\r\n   -config fn   Pull arguments and config options from file fn\r\n   -verbose     Print extra information during execution and analysis\r\n   -m mode      Mode to initiate for suspend (default: mem)\r\n   -o name      Overrides the output subdirectory name when running a new test\r\n                default: suspend-{date}-{time}\r\n   -rtcwake t   Wakeup t seconds after suspend, set t to \"off\" to disable (default: 15)\r\n   -addlogs     Add the dmesg and ftrace logs to the html output\r\n   -noturbostat Dont use turbostat in freeze mode (default: disabled)\r\n   -srgap       Add a visible gap in the timeline between sus/res (default: disabled)\r\n   -skiphtml    Run the test and capture the trace logs, but skip the timeline (default: disabled)\r\n   -result fn   Export a results table to a text file for parsing.\r\n   -wifi        If a wifi connection is available, check that it reconnects after resume.\r\n   -wifitrace   Trace kernel execution through wifi reconnect.\r\n   -netfix      Use netfix to reset the network in the event it fails to resume.\r\n   -debugtiming Add timestamp to each printed line\r\n  [testprep]\r\n   -sync        Sync the filesystems before starting the test\r\n   -rs on/off   Enable/disable runtime suspend for all devices, restore all after test\r\n   -display m   Change the display mode to m for the test (on/off/standby/suspend)\r\n  [advanced]\r\n   -gzip        Gzip the trace and dmesg logs to save space\r\n   -cmd {s}     Run the timeline over a custom command, e.g. \"sync -d\"\r\n   -proc        Add usermode process info into the timeline (default: disabled)\r\n   -dev         Add kernel function calls and threads to the timeline (default: disabled)\r\n   -x2          Run two suspend/resumes back to back (default: disabled)\r\n   -x2delay t   Include t ms delay between multiple test runs (default: 0 ms)\r\n   -predelay t  Include t ms delay before 1st suspend (default: 0 ms)\r\n   -postdelay t Include t ms delay after last resume (default: 0 ms)\r\n   -mindev ms   Discard all device blocks shorter than ms milliseconds (e.g. 0.001 for us)\r\n   -multi n d   Execute <n> consecutive tests at <d> seconds intervals. If <n> is followed\r\n                by a \"d\", \"h\", or \"m\" execute for <n> days, hours, or mins instead.\r\n                The outputs will be created in a new subdirectory with a summary page.\r\n   -maxfail n   Abort a -multi run after n consecutive fails (default is 0 = never abort)\r\n  [debug]\r\n   -f           Use ftrace to create device callgraphs (default: disabled)\r\n   -ftop        Use ftrace on the top level call: \"pm_suspend\" (default: disabled)\r\n   -maxdepth N  limit the callgraph data to N call levels (default: 0=all)\r\n   -expandcg    pre-expand the callgraph data in the html output (default: disabled)\r\n   -fadd file   Add functions to be graphed in the timeline from a list in a text file\r\n   -filter \"d1,d2,...\" Filter out all but this comma-delimited list of device names\r\n   -mincg  ms   Discard all callgraphs shorter than ms milliseconds (e.g. 0.001 for us)\r\n   -cgphase P   Only show callgraph data for phase P (e.g. suspend_late)\r\n   -cgtest N    Only show callgraph data for test N (e.g. 0 or 1 in an x2 run)\r\n   -timeprec N  Number of significant digits in timestamps (0:S, [3:ms], 6:us)\r\n   -cgfilter S  Filter the callgraph output in the timeline\r\n   -cgskip file Callgraph functions to skip, off to disable (default: cgskip.txt)\r\n   -bufsize N   Set trace buffer size to N kilo-bytes (default: all of free memory)\r\n   -devdump     Print out all the raw device data for each phase\r\n   -cgdump      Print out all the raw callgraph data\r\n\r\nOther commands:\r\n   -modes       List available suspend modes\r\n   -status      Test to see if the system is enabled to run this tool\r\n   -fpdt        Print out the contents of the ACPI Firmware Performance Data Table\r\n   -wificheck   Print out wifi connection info\r\n   -x<mode>     Test xset by toggling the given mode (on/off/standby/suspend)\r\n   -sysinfo     Print out system info extracted from BIOS\r\n   -devinfo     Print out the pm settings of all devices which support runtime suspend\r\n   -cmdinfo     Print out all the platform info collected before and after suspend/resume\r\n   -flist       Print the list of functions currently being captured in ftrace\r\n   -flistall    Print all functions capable of being captured in ftrace\r\n   -summary dir Create a summary of tests in this dir [-genhtml builds missing html]\r\n  [redo]\r\n   -ftrace ftracefile  Create HTML output using ftrace input (used with -dmesg)\r\n   -dmesg dmesgfile    Create HTML output using dmesg (used with -ftrace)\r\n```\r\n\r\n## 2.5 第一次測試 pm-graph\r\n在根目錄底下創建一個新目錄 sleep_analysis，並移動路徑到 sleep_analysis，先測試系統狀態 `Suspend-to-Idle`，執行以下指令：\r\n```shell\r\nsudo sleepgraph -m mem-s2idle\r\n```\r\n\r\n\r\n\r\n結果如下：\r\n```shell\r\nChecking this system (AI)...\r\n    have root access: YES\r\n    is sysfs mounted: YES\r\n    is \"mem-s2idle\" a valid power mode: YES\r\n    is ftrace supported: YES\r\n    are kprobes supported: YES\r\n    timeline data source: FTRACE (all trace events found)\r\n    is rtcwake supported: YES\r\n    optional commands this tool may use for info:\r\n        turbostat: FOUND\r\n        mcelog: MISSING\r\n        lspci: FOUND\r\n        lsusb: FOUND\r\n        netfix: FOUND\r\nos-version              : Ubuntu 25.04\r\nbaseboard-manufacturer  : ASUSTeK COMPUTER INC.\r\nbaseboard-product-name  : FX707ZU4\r\nbaseboard-serial-number : C4S33M200RR\r\nbaseboard-version       : 1.0\r\nbios-release-date       : 10/14/2024\r\nbios-vendor             : American Megatrends International, LLC.\r\nbios-version            : FX707ZU4.329\r\nchassis-manufacturer    : ASUSTeK COMPUTER INC.\r\nchassis-serial-number   : R3NRKD022289137\r\nchassis-version         : 1.0\r\nprocessor-version       : 12th Gen Intel(R) Core(TM) i7-12700H\r\nsystem-manufacturer     : ASUSTeK COMPUTER INC.\r\nsystem-product-name     : ASUS TUF Gaming F17 FX707ZU4_FX707ZU4\r\nsystem-serial-number    : R3NRKD022289137\r\nsystem-version          : 1.0\r\ncpucount                : 20\r\nmemtotal                : 31955264 kB\r\nmemfree                 : 26509904 kB\r\nINITIALIZING FTRACE\r\nINITIALIZING KPROBES\r\nSUSPEND START\r\nwill issue an rtcwake in 15 seconds\r\nRESUME COMPLETE\r\nCAPTURING DMESG\r\nCAPTURING TRACE\r\nPROCESSING: suspend-250726-143745/AI_freeze.html\r\nDONE:       suspend-250726-143745/AI_freeze.html\r\n\r\n\r\n```\r\n\r\n會在執行的目錄底下產生一個目錄，裡面是使用 ```sleepgraph``` 做測試的報告。\r\n```shell\r\nlab@AI:~/sleep_analysis/suspend-250726-143745$ ll\r\ntotal 1388\r\ndrwxr-xr-x 2 lab lab   4096 Jul 26 14:38 ./\r\ndrwxrwxr-x 3 lab lab   4096 Jul 26 14:37 ../\r\n-rw-r--r-- 1 lab lab  23832 Jul 26 14:38 AI_freeze_dmesg.txt\r\n-rw-r--r-- 1 lab lab 796599 Jul 26 14:38 AI_freeze_ftrace.txt\r\n-rw-r--r-- 1 lab lab 589162 Jul 26 14:38 AI_freeze.html\r\n```\r\n用瀏覽器打開 html 報告後，會出現下面的裝置時間軸圖。\r\n![image](https://hackmd.io/_uploads/Bk0t_lfwxx.png)\r\n\r\n可以看到裝置 nvidia @ 0000:01:00.0 {nvidia} 的 Suspend 時間最久：\r\n- Suspend 耗時：372.625 ms\r\n- Resume 耗時：721.259 ms\r\n\r\n![image](https://hackmd.io/_uploads/HkaetxzPge.png)\r\n\r\n另外，裝置 pcieport @ 0000:00:01.0 {pcieport} 的 Resume noirq 時間則最久：\r\n\r\n- 耗時：1116.212 ms\r\n\r\n\r\n\r\n## 2.6 第一次測試 Perfetto\r\n按照[Perfetto 官網](https://perfetto.dev/docs/getting-started/system-tracing)的步驟，執行以下指令從 GitHub 下載 ```tracebox``` 二進位檔：\r\n```shell\r\ncurl -LO https://get.perfetto.dev/tracebox\r\nchmod +x tracebox\r\n```\r\n\r\n\r\n\r\n接下來，我們試著捕捉一個 Trace （追蹤），首先新建一個 .cfg 設定檔， 並命名為 suspend_resume。\r\n```shell\r\nbuffers {\r\n  size_kb: 100024\r\n  fill_policy: RING_BUFFER\r\n}\r\n\r\ndata_sources {\r\n  config {\r\n    name: \"linux.ftrace\"\r\n    target_buffer: 0\r\n    ftrace_config {\r\n        ftrace_events: \"sched_switch\"\r\n        ftrace_events: \"sched_waking\"\r\n        ftrace_events: \"sched_wakeup_new\"\r\n\r\n        ftrace_events: \"sched_process_exec\"\r\n        ftrace_events: \"sched_process_exit\"\r\n        ftrace_events: \"sched_process_fork\"\r\n        ftrace_events: \"sched_process_free\"\r\n        ftrace_events: \"sched_process_hang\"\r\n        ftrace_events: \"sched_process_wait\"\r\n\r\n        ftrace_events: \"irq_handler_entry\"\r\n        ftrace_events: \"irq_handler_exit\"\r\n        ftrace_events: \"suspend_resume\"\r\n    }\r\n  }\r\n}\r\n\r\nduration_ms: 30000\r\n```\r\n\r\n並執行以下指令：\r\n```shell\r\nsudo ./tracebox -o trace_file.perfetto-trace --txt -c suspend_resume.cfg\r\n```\r\n\r\n接著移動路徑到 sleep_analysis，先測試系統狀態 `Suspend-to-Idle`，執行以下指令：\r\n```shell\r\nsudo sleepgraph -m mem-s2idle\r\n```\r\n\r\n到瀏覽器上的 [ui.perfetto.dev](https://ui.perfetto.dev/) 並打看 trace_file.perfetto-trace 檔案，結果如下。\r\n![image](https://hackmd.io/_uploads/ryLwEWGPlg.png)\r\n\r\n因為測量範圍過大，因此無法精確知道更清楚的細節。但是進一步放大，可以發現，在 `suspend_enter` 階段耗時 1,915 ms，是整個流程裡面耗時最久的。\r\n\r\n![image](https://hackmd.io/_uploads/r1HbSZzwle.png)\r\n\r\n\r\n# 3. LKML Patch\r\n本次要探討的 Patch 都和系統休眠有關，由電源管理模組的維護者 [Rafael J. Wysocki](https://www.linkedin.com/in/rafael-wysocki-092a4b90/?originalSubdomain=pl) 提交：\r\n\r\n1. [PM: sleep: Resume children after resuming the parent](https://github.com/torvalds/linux/commit/0cbef962ce1ff344ecfe32d1c874978f1f7d410a)，2025.4.22\r\n2. [PM: sleep: Suspend async parents after suspending children](https://github.com/torvalds/linux/commit/aa7a9275ab814705b60ba8274277d91da6ab6122)，2025.4.22\r\n3. [PM: sleep: Make suspend of devices more asynchronous](https://github.com/torvalds/linux/commit/443046d1ad66607f324c604b9fbdf11266fa8aad)，2025.4.22\r\n4. [PM: sleep: Make async resume handle consumers like children](https://github.com/torvalds/linux/commit/ed18738fff025df2a424d3b21e895992e6cb230a)，2025.7.3\r\n5. [PM: sleep: Make async suspend handle suppliers like parents](https://github.com/torvalds/linux/commit/06799631d52261162d356623d14381d9f30223dc)，2025.7.3\r\n\r\n\r\n## 3.1 Resume children after resuming the parent\r\n\r\n裝置的休眠與喚醒處理（特別是喚醒），會產生不必要的額外開銷。這是因為有些裝置在等待其他裝置完成處理時，就已經開始了新的非同步工作項目。\r\n\r\n為了在喚醒路徑中減少這個問題，維護者觀察到：在喚醒父裝置後，才開始非同步喚醒其子裝置，很可能比提前開始喚醒產生**更少**的排程和記憶體管理方面的「雜訊」，同時也**不會**大幅增加喚醒所需的時間。\r\n\r\n因此，程式碼被修改為：\r\n\r\n在裝置喚醒的每個階段，當父裝置的處理完成後，才開始其子裝置的非同步喚醒。\r\n\r\n只有在沒有父裝置的情況下，才會提前開始非同步喚醒。\r\n\r\n在開始非同步喚醒某個裝置之前，會先檢查該裝置是否可以被非同步喚醒，以防它必須等待另一個已經在非同步喚醒中的裝置。\r\n\r\n除了使裝置的非同步喚醒對運算資源相對較少的系統更友善之外，這項變更也是為休眠路徑中的類似變更奠定基礎。\r\n\r\n在經過測試的系統上，這項改動本身並不會以可測量的方式影響整個系統的喚醒時間。\r\n\r\n以下來閱讀與解析於 drivers/base/power/main.c 這次維護者所提交的程式碼。\r\n\r\n![image](https://hackmd.io/_uploads/HyMCMIsweg.png)\r\n\r\n在核心驅動程式電源管理模組中，引入了一個新的互斥鎖 `async_wip_mtx` 以防止存取非同步任務狀態時的競爭條件。同時，在 `__dpm_async` 函式開頭新增了一項前置條件檢查，該檢查會確認 `dev->power.work_in_progress` 旗標，以避免在同一裝置已有任務在執行時，重複排程多餘的電源管理操作，從而提升系統穩定性並防止不必要的工作。\r\n\r\n\r\n![image](https://hackmd.io/_uploads/Sk5gXUsvgg.png)\r\n\r\n新增 `dpm_async_fn` 作為一個執行緒安全 (Thread-Safe) 的封裝函式 (Wrapper)。它利用 `guard(mutex)` 巨集以 RAII 的風格自動管理互斥鎖 `async_wip_mtx`，確保在安全的情況下呼叫內部的核心邏輯 `__dpm_async`。\r\n\r\n新增 `dpm_async_with_cleanup`，一個帶有錯誤清理機制的穩固封裝函式 (Robust Wrapper)。它不僅安全地呼叫 `__dpm_async`，更重要的是處理了失敗情境：如果任務排程失敗 (`__dpm_async` 回傳 `false`)，它會執行清理工作，將 `work_in_progress` 旗標重設為 `false`，以確保系統狀態的一致性，防止裝置卡在錯誤的狀態。\r\n\r\n新增 `dpm_async_resume_children` 作為一個高階的協同運作函式 (High-Level Orchestrator)。它使用核心的 `device_for_each_child` 輔助函式來遍歷指定裝置的所有子裝置。其關鍵設計在於，它傳遞了我們剛才定義的穩固封裝函式 `dpm_async_with_cleanup` 作為回呼 (Callback)，從而確保對每一個子裝置的非同步喚醒操作都是安全且帶有錯誤清理機制的。\r\n\r\n\r\n![image](https://hackmd.io/_uploads/BJVz7IoPgl.png)\r\n\r\n在 `aynce_resume_noirq` 改成是優先處理「根裝置 (root devices)」，以便它們的子裝置可以盡快開始喚醒。本來的寫法是優先觸發 \"非同步\" 裝置的喚醒，現在則是優先開始處理 \"非同步的根\" 裝置。\r\n其新增了一個輔助函式 `dpm_root_device` 來判斷根裝置。同時，引入了新的回呼函式    `async_resume_noirq`，用於實現一種級聯式 (cascading) 的喚醒機制：即父裝置完成處理後，立即觸發其所有子裝置的非同步喚醒流程，從而最大化系統資源利用率並縮短整體喚醒時間。\r\n\r\n![image](https://hackmd.io/_uploads/r1ClI_ovgg.png)\r\n\r\n在 `device_resume_early` 函式中新增了對 `dpm_async_resume_children` 的呼叫，從而建立了級聯喚醒機制。這項重構使得父裝置在完成自身處理後，能立即、並行地觸發其子裝置的喚醒流程，顯著提升了 `early resume` 階段的效率與並行度。\r\n\r\n![image](https://hackmd.io/_uploads/B1A9XUsvee.png)\r\n\r\n修改了核心的 `async_resume` 回呼函式，以實現級聯式 (cascading) 的並行喚醒策略。函式中新增了一個條件判斷，當確認處理的裝置是根裝置 (root device) 時，便會立即呼叫 `dpm_async_resume_children`，以 `async_resume` 自身作為新的回呼，從而遞迴地觸發其整個子樹的非同步喚醒流程。這個改動是實現『根裝置優先』優化策略的關鍵步驟，旨在最大化並行處理，縮短系統總體喚醒時間。\r\n\r\n\r\n## 3.2 Suspend async parents after suspending children\r\n為了與先前影響喚醒路徑的變更類似，此項變更旨在優化休眠路徑。\r\n\r\ndevice_suspend() 函數被修改為：在處理完裝置本身後，才開始其父裝置的非同步休眠。\r\n\r\ndpm_suspend() 函數被修改為：會優先處理「非同步」的葉子裝置（leaf devices，即沒有子裝置的裝置）。這樣一來，它們就不必等待它們不依賴的「同步」裝置。\r\n\r\n這項改動的結果非常顯著：在維護者的辦公室測試的 Dell XPS13 9360 上，此項變更將裝置休眠的總時間減少了約 100 毫秒（超過 20%）。\r\n\r\n以下來閱讀於 drivers/base/power/main.c 這次維護者所提交的程式碼。\r\n\r\n![image](https://hackmd.io/_uploads/r1OQ9ujwex.png)\r\n\r\n新增了一個輔助判斷函式 (predicate function) `dpm_leaf_device`，用於高效地判斷一個裝置是否為裝置樹中的葉節點 (leaf node)。該函式透過 `lockdep_assert_held()`` 來強制執行鎖定協議，確保呼叫者已持有 `dpm_list_mtx`。其核心邏輯使用 `device_find_any_child()`` 來快速檢查是否存在任何子裝置，而非遍歷全部，以提升效能。同時，它遵循了核心的引用計數 (reference counting) 機制，在找到子裝置後會呼叫 `put_device()` 來釋放其引用，防止資源洩漏。\r\n\r\n![image](https://hackmd.io/_uploads/B15NqdsDge.png)\r\n\r\n此函式 `dpm_async_suspend_parent` 的主要功能是將非同步暫停操作沿著裝置樹向上傳播 (propagate up)，為指定裝置的父裝置安排相同的暫停任務。其關鍵設計在於一個防禦性的前置條件檢查，用以預防在複雜的非同步情境下可能發生的 `use-after-free` 競爭條件。透過在存取父裝置前，先呼叫 `device_pm_initialized()`` 來驗證子裝置自身的狀態，該函式確保了即使在暫停期間發生並行的裝置移除事件，它也不會存取到已被釋放的父裝置記憶體，從而顯著提升了電源管理子系統的穩固性 (robustness)。\r\n\r\n![image](https://hackmd.io/_uploads/SkjF5dsvgl.png)\r\n![image](https://hackmd.io/_uploads/r17n5uswxl.png)\r\n\r\n\r\n`dpm_suspend` 是系統範圍內裝置暫停流程的核心進入點。它採用了「葉節點優先 (leaf-first)」的核心策略來處理裝置間的依賴關係，透過反向遍歷裝置列表，並優先為所有葉節點啟動非同步暫停。隨後，主迴圈以混合模式處理剩餘裝置，對需要同步處理的裝置執行阻塞式呼叫，並跳過已在非同步流程中的裝置。整個流程的關鍵在於最後的 `async_synchronize_full()` 呼叫，它作為一個同步屏障，會等待所有非同步任務完成，以確保在函式返回前，所有裝置均已成功進入暫停狀態。這個設計有效地利用了非同步處理來最大化並行度，同時透過嚴格的順序和同步機制保證了系統狀態的穩定性。\r\n\r\n\r\n\r\n\r\n## 3.3 Make suspend of devices more asynchronous\r\n為了與先前所做的變更保持一致，這次將非同步休眠的優化應用到更細緻的階段。\r\n\r\ndevice_suspend_late() 和 device_suspend_noirq() 這兩個函數被修改，使其在處理完裝置本身後，才開始其父裝置的非同步休眠。\r\n\r\ndpm_suspend_late() 和 dpm_noirq_suspend_devices() 函數也做出相應調整，會優先處理「非同步」的葉子裝置（沒有子裝置的裝置）。這樣能讓它們不必等待不相關的裝置，從而避免不必要的延遲。\r\n\r\n這項變更在某些系統上確實能測量到休眠總時間的縮短，但效果並不明顯。\r\n\r\n## 3.4 Make async resume handle consumers like children\r\n這則提交的目標是避免在裝置供應鏈中，不必要的非同步喚醒處理。避免為有供應商（suppliers）的裝置提前開始非同步喚醒。在喚醒裝置本身之後，立刻開始其「消費者」（consumers）的非同步喚醒處理。\r\n\r\n**供應商與消費者：**\r\n\r\n- 供應商 (Supplier)： 提供服務或資源給其他裝置的裝置，例如一個匯流排控制器（bus controller）是其上所有 USB 裝置的供應商。\r\n- 消費者 (Consumer)： 依賴其他裝置提供服務或資源的裝置，例如一個 USB 隨身碟就是 USB 匯流排控制器的消費者。\r\n\r\n**優化邏輯：**\r\n\r\n- 舊方法： 可能會提前為消費者裝置啟動非同步喚醒，但此時其供應商可能還未喚醒，導致消費者必須等待，從而產生無謂的排程與開銷。\r\n- 新方法： 只有在供應商（例如父裝置或服務提供者）被喚醒後，才開始喚醒其消費者（例如子裝置或服務依賴者）。這種順序與裝置的物理依賴關係更為一致，能夠減少不必要的等待和資源浪費，使整個喚醒流程更有效率。\r\n\r\n以下來閱讀與解析於 drivers/base/power/main.c 這次維護者所提交的程式碼。\r\n\r\n![image](https://hackmd.io/_uploads/Bk2EWR2Dge.png)\r\n\r\n`dpm_async_resume_subordinate` 是一個高階的抽象封裝函式 (Abstraction Wrapper)，旨在統一處理並喚醒所有依賴於指定裝置的「下屬 (subordinate)」裝置。此函式擴展了傳統僅考慮父子階層的依賴模型，將其職責分為兩個關鍵部分：\r\n1. 處理階層式子裝置：\r\n首先，它呼叫 `dpm_async_resume_children`，處理裝置樹中傳統的父子依賴關係，確保所有直屬子裝置被加入非同步喚醒佇列。\r\n2. 處理功能性消費者裝置：\r\n接著，它遍歷該裝置的 `device_link` 消費者列表 (consumers)，為每一個處於活動狀態的消費者裝置安排非同步喚醒。這解決了非階層式的功能性依賴問題，確保了例如感測器（消費者）不會在其所需的電源控制器（供應商）準備就緒前被喚醒。\r\n\r\n透過將這兩種不同類型的依賴關係封裝在一個語義清晰的函式中，`dpm_async_resume_subordinate` 顯著提升了電源管理子系統的穩固性 (robustness)。它能有效防止因喚醒順序錯亂而導致的競爭條件，並為上層呼叫者提供了一個更簡潔、更抽象的 API，提升了整體程式碼的可讀性與可維護性。\r\n\r\n![image](https://hackmd.io/_uploads/H188Z0hwxx.png)\r\n\r\n此修改透過強化 `dpm_root_device` 函式的邏輯，重新定義了電源管理中的「根裝置」。舊有的定義僅考慮裝置樹的階層關係，而新的定義則更加嚴謹，要求一個真正的「根裝置」必須同時滿足「無父裝置」與「無功能性供應商 (no suppliers)」 兩個條件。這一改動確保了只有完全沒有依賴的裝置才能作為喚醒流程的起點，從而使整個依賴圖 (dependency graph) 的處理順序更加準確與穩固。此外，為了保證執行緒安全地存取 `device_links` 列表，函式中新增了 `lockdep_assert_held()`，強制呼叫者必須持有指定的鎖，以此來強化整體的鎖定協議。\r\n\r\n\r\n## 3.5 Make async suspend handle suppliers like parents\r\n這則提交的目標是優化裝置供應鏈中的非同步休眠處理。避免為有消費者（consumers）的裝置提前開始非同步休眠。在休眠裝置本身之後，立刻開始其「供應商」（suppliers）的非同步休眠處理。\r\n\r\n**優化順序：**\r\n\r\n- 舊方法： 可能會提前休眠供應商，而此時消費者裝置可能還在使用供應商提供的服務。這會導致狀態不一致或錯誤。\r\n- 新方法： 只有在消費者（例如子裝置）被休眠後，才開始休眠其供應商（例如父裝置）。這確保了服務的依賴關係被正確處理，避免了在休眠過程中因依賴性錯誤而產生的延遲或問題。\r\n\r\n\r\n以下來閱讀與解析於 drivers/base/power/main.c 這次維護者所提交的程式碼。\r\n\r\n![image](https://hackmd.io/_uploads/rkXyB02Pgg.png)\r\n\r\n### 函式總體目標\r\n此函式的主要目標是，在一個裝置 (dev) 自身完成暫停後，接續地、安全地觸發所有它所依賴的「上級」裝置的暫停流程。這裡的「上級」包含了階層上的父裝置和功能上的供應商裝置。\r\n\r\n### 逐行程式碼解析\r\n\r\n```clike\r\nstatic void dpm_async_suspend_superior(struct device *dev, async_func_t func)\r\n```\r\n\r\n\r\n語法解析：定義一個名為 `dpm_async_suspend_superior` 的靜態函式 (`static` 表示此函式僅在此檔案內可見)，它不回傳任何值 (void)。它接收兩個參數：一個指向裝置結構的指標 `dev`，以及一個函式指標 `func` (代表要執行的非同步任務)。\r\n\r\n功能目的：作為向上傳播暫停流程的進入點。\r\n\r\n```clike\r\nstruct device_link *link;\r\nint idx;\r\n```\r\n\r\n語法解析：宣告兩個區域變數。`link` 用於在稍後的迴圈中指向 `device_link` 結構；`idx` 用於儲存鎖定操作回傳的索引值。\r\n功能目的：為後續的迴圈迭代和鎖定操作做準備。\r\n\r\n```clike\r\nif (!dpm_async_suspend_parent(dev, func))\r\n    return;\r\n```\r\n\r\n語法解析：呼叫 `dpm_async_suspend_parent` 函式。\r\n功能目的：這是處理向上依賴的第一步：處理階層上的父裝置。它會為 dev 的父裝置安排非同步暫停。\r\n\r\n根據我們之前的分析，`dpm_async_suspend_parent` 函式應為 `void` 型別，所以 `if (!...)` 的判斷在邏輯上是不成立的，這很可能是開發中版本的程式碼筆誤。其真實意圖應為 `dpm_async_suspend_parent(dev, func);`，即無條件先處理父裝置。\r\n\r\n```clike\r\nidx = device_links_read_lock();\r\n```\r\n\r\n語法解析：呼叫 `device_links_read_lock()` 函式。\r\n功能目的：獲取一個讀取鎖 (read lock)。因為 `device_link` 鏈接串列可能會被系統的其他部分同時修改，為了能安全地遍歷這個鏈接串列，必須先上鎖。這個鎖回傳一個整數 `idx` 作為「票根」，解鎖時需要用到。\r\n\r\n```clike\r\nlist_for_each_entry_rcu(link, &dev->links.suppliers, c_node)\r\n```\r\n\r\n語法解析：這是一個 Linux 核心中常用的巨集，用來安全地遍歷一個 RCU (Read-Copy-Update) 保護的鏈結串列。\r\n功能目的：遍歷 `dev` 的所有「供應商」。供應商是指那些 `dev` 在功能上所依賴的裝置。這是處理向上依賴的第二步。\r\n\r\n```clike\r\nif (READ_ONCE(link->status) != DL_STATE_DORMANT)\r\n```\r\n\r\n語法解析：檢查 `device_link` 的狀態。`READ_ONCE` 是一個記憶體屏障巨集，確保讀取的是最新的值，避免因編譯器優化導致的讀取錯誤。`DL_STATE_DORMANT` 代表該連結處於「休眠」或非活動狀態。\r\n功能目的：確認這個功能性依賴是有效的。如果依賴連結是活動的，才需要處理它的供應商。\r\n\r\n```clike\r\ndpm_async_with_cleanup(link->supplier, func);\r\n```\r\n\r\n語法解析：如果上述 if 條件成立，則呼叫 `dpm_async_with_cleanup` 函式。\r\n功能目的：為這個有效的供應商裝置 (link->supplier)，安排同一個非同步暫停任務 (func)。這是整個函式最終要執行的核心動作之一。\r\n\r\n```clike\r\ndevice_links_read_unlock(idx);\r\n```\r\n\r\n語法解析：呼叫 `device_links_read_unlock()` 函式，並傳入之前上鎖時得到的「票根」`idx`。\r\n功能目的：釋放讀取鎖，讓其他需要修改 `device_link` 列表的程式可以繼續執行。上鎖和解鎖成對出現，是保證系統穩定的基本要求。\r\n\r\n\r\n# 4. Merge LKML Patch and Measure Performance\r\n\r\n## 4.1 簡介\r\n\r\n以下來檢視這五個提交的每一個 Patch：\r\n[[PATCH v3 0/5] PM: sleep: Improvements of async suspend and resume of devices](https://lore.kernel.org/linux-pm/10629535.nUPlyArG6x@rjwysocki.net/)\r\n[[PATCH v3 1/5] PM: sleep: Resume children after resuming the parent](https://lore.kernel.org/linux-pm/22630663.EfDdHjke4D@rjwysocki.net/)\r\n[[PATCH v3 2/5] PM: sleep: Suspend async parents after suspending children](https://lore.kernel.org/linux-pm/3541233.QJadu78ljV@rjwysocki.net/)\r\n[[PATCH v3 3/5] PM: sleep: Make suspend of devices more asynchronous](https://lore.kernel.org/linux-pm/1924195.CQOukoFCf9@rjwysocki.net/)\r\n[[PATCH v3 4/5] PM: sleep: Make async suspend handle suppliers like parents](https://lore.kernel.org/linux-pm/2651185.Lt9SDvczpP@rjwysocki.net/)\r\n[[PATCH v3 5/5] PM: sleep: Make async resume handle consumers like children](https://lore.kernel.org/linux-pm/2229735.Mh6RI2rZIc@rjwysocki.net/)\r\n\r\n\r\n在 [[PATCH v3 0/5] PM: sleep: Improvements of async suspend and resume of devices](https://lore.kernel.org/linux-pm/10629535.nUPlyArG6x@rjwysocki.net/) 作者總結了這次提交的效能分析結果：\r\n\r\n首先，`Baseline` 是 `linux-pm.git/testing` 分支，`Parent/child` 是分支使用 Patches [1-3/5]，`Device links` 是分支使用 Patch [1-5/5]。\r\n\r\n`s/r` 指的是 `regular` suspend/resume；`noRPM` 指的是 `late` suspend 和 `early` resume；`noIRQ` 指的是 `noirq` 階段的 suspend/resume。\r\n\r\n以下表格中的數字是 suspend 和 resume 在每一個階段的時間以毫秒為單位。\r\n\r\n<style>\r\n/* --- Modern Dark Theme Palette & Layout --- /\r\n.perf-table-container {\r\nfont-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, sans-serif;\r\nbackground-color: #1A1A1B;\r\npadding: 16px;\r\nborder-radius: 8px;\r\n}\r\n.perf-table {\r\nwidth: 100%;\r\nborder-collapse: collapse;\r\ncolor: #D7DADC; / Light gray text for readability /\r\n}\r\n.perf-table th, .perf-table td {\r\ntext-align: center;\r\npadding: 12px 10px;\r\nborder-bottom: 1px solid #343638; / Subtle row separators /\r\n}\r\n.perf-table thead th {\r\nfont-size: 0.9em;\r\nfont-weight: 600;\r\ncolor: #B0B3B8;\r\nborder-bottom-width: 2px;\r\nborder-bottom-color: #4d4d4d;\r\ntext-transform: uppercase;\r\nletter-spacing: 0.5px;\r\n}\r\n.perf-table tbody tr:hover {\r\nbackground-color: #2a2a2c; / Interactive hover effect /\r\n}\r\n.perf-table td:first-child, .perf-table th:first-child {\r\ntext-align: left;\r\npadding-left: 15px;\r\n}\r\n.run-number {\r\nfont-size: 1.2em;\r\nfont-weight: bold;\r\ncolor: #fff;\r\n}\r\n/ --- Data Visualization Classes --- /\r\n.metric {\r\nfont-size: 1.1em;\r\nfont-weight: 500;\r\n}\r\n.improvement {\r\ncolor: #2ECC71; / Green for improvement /\r\nfont-weight: 600;\r\n}\r\n.neutral {\r\ncolor: #95A5A6; / Gray for neutral or minor changes */\r\n}\r\n.percentage {\r\ndisplay: block;\r\nfont-size: 0.8em;\r\ncolor: #7f8c8d;\r\nmargin-top: 2px;\r\n}\r\n</style>\r\n\r\n<div class=\"perf-table-container\">\r\n<table class=\"perf-table\">\r\n<thead>\r\n<tr>\r\n<th rowspan=\"2\">測試回合</th>\r\n<th rowspan=\"2\">階段 (Phase)</th>\r\n<th colspan=\"2\">基準 (Baseline)</th>\r\n<th colspan=\"2\">父子裝置優先 (Parent/child)</th>\r\n<th colspan=\"2\">裝置連結優先 (Device links)</th>\r\n</tr>\r\n<tr>\r\n<th>Suspend</th>\r\n<th>Resume</th>\r\n<th>Suspend</th>\r\n<th>Resume</th>\r\n<th>Suspend</th>\r\n<th>Resume</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td rowspan=\"3\"><span class=\"run-number\">1</span></td>\r\n<td>s/r</td>\r\n<td><span class=\"metric\">427</span></td>\r\n<td><span class=\"metric\">449</span></td>\r\n<td><span class=\"metric improvement\">298 ▼<span class=\"percentage\">-30.2%</span></span></td>\r\n<td><span class=\"metric neutral\">450</span></td>\r\n<td><span class=\"metric improvement\">294 ▼<span class=\"percentage\">-31.1%</span></span></td>\r\n<td><span class=\"metric neutral\">442</span></td>\r\n</tr>\r\n<tr>\r\n<td>noRPM</td>\r\n<td>13</td>\r\n<td>1</td>\r\n<td>13</td>\r\n<td>1</td>\r\n<td>13</td>\r\n<td>1</td>\r\n</tr>\r\n<tr>\r\n<td>noIRQ</td>\r\n<td>31</td>\r\n<td>25</td>\r\n<td>28</td>\r\n<td>24</td>\r\n<td>28</td>\r\n<td>26</td>\r\n</tr>\r\n<tr>\r\n<td rowspan=\"3\"><span class=\"run-number\">2</span></td>\r\n<td>s/r</td>\r\n<td><span class=\"metric\">408</span></td>\r\n<td><span class=\"metric\">442</span></td>\r\n<td><span class=\"metric improvement\">298 ▼<span class=\"percentage\">-27.0%</span></span></td>\r\n<td><span class=\"metric neutral\">443</span></td>\r\n<td><span class=\"metric improvement\">301 ▼<span class=\"percentage\">-26.2%</span></span></td>\r\n<td><span class=\"metric neutral\">447</span></td>\r\n</tr>\r\n<tr>\r\n<td>noRPM</td>\r\n<td>13</td>\r\n<td>1</td>\r\n<td>13</td>\r\n<td>1</td>\r\n<td>13</td>\r\n<td>1</td>\r\n</tr>\r\n<tr>\r\n<td>noIRQ</td>\r\n<td>32</td>\r\n<td>25</td>\r\n<td>30</td>\r\n<td>25</td>\r\n<td>28</td>\r\n<td>25</td>\r\n</tr>\r\n<tr>\r\n<td rowspan=\"3\"><span class=\"run-number\">3</span></td>\r\n<td>s/r</td>\r\n<td><span class=\"metric\">408</span></td>\r\n<td><span class=\"metric\">444</span></td>\r\n<td><span class=\"metric improvement\">310 ▼<span class=\"percentage\">-24.0%</span></span></td>\r\n<td><span class=\"metric neutral\">450</span></td>\r\n<td><span class=\"metric improvement\">298 ▼<span class=\"percentage\">-27.0%</span></span></td>\r\n<td><span class=\"metric neutral\">439</span></td>\r\n</tr>\r\n<tr>\r\n<td>noRPM</td>\r\n<td>13</td>\r\n<td>1</td>\r\n<td>13</td>\r\n<td>1</td>\r\n<td>13</td>\r\n<td>1</td>\r\n</tr>\r\n<tr>\r\n<td>noIRQ</td>\r\n<td>31</td>\r\n<td>24</td>\r\n<td>31</td>\r\n<td>26</td>\r\n<td>31</td>\r\n<td>24</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n</div>\r\n\r\n\r\n\r\n## 4.2 實驗步驟\r\n\r\n經過查詢得知這次提交是在 [6.16-rc3 LKML Patch](https://www.spinics.net/lists/kernel/msg5734763.html?) 裡面。\r\n\r\n首先我們要建立對照組和實驗組，對照組是第一個 Patch 之前的分支，實驗組則是加入這五個 Patch 之後的分支。\r\n\r\n\r\n### 建立對照組\r\n\r\n```shell\r\nlab@AI:~/Downloads$ git clone https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git\r\nCloning into 'linux'...\r\nremote: Enumerating objects: 11031512, done.\r\nremote: Counting objects: 100% (2117/2117), done.\r\nremote: Compressing objects: 100% (1186/1186), done.\r\nremote: Total 11031512 (delta 1399), reused 1263 (delta 930), pack-reused 11029395 (from 1)\r\nReceiving objects: 100% (11031512/11031512), 3.05 GiB | 8.95 MiB/s, done.\r\nResolving deltas: 100% (9063034/9063034), done.\r\nUpdating files: 100% (90497/90497), done.\r\n```\r\n\r\n\r\n```shell\r\nlab@AI:~/Downloads/linux$ git checkout -b v6.16-baseline 0cbef962ce1f~1\r\nUpdating files: 100% (14188/14188), done.\r\nPrevious HEAD position was 86731a2a651e Linux 6.16-rc3\r\nSwitched to a new branch 'v6.16-baseline'\r\n\r\n# 複製您目前的系統設定檔\r\ncp /boot/config-$(uname -r) .config\r\n\r\n# 使用 sed 指令強制關閉憑證選項\r\nsed -i 's/CONFIG_SYSTEM_TRUSTED_KEYS/#CONFIG_SYSTEM_TRUSTED_KEYS/g' .config\r\n\r\n# 使用不會提問的 olddefconfig 來自動完成設定\r\nmake olddefconfig\r\n\r\n# 開始編譯\r\nmake -j$(nproc)\r\n\r\n# 安裝模組與核心\r\nsudo make modules_install\r\nsudo make install\r\n```\r\n\r\n確認目前的系統核心版本以及，程式庫裡面是否有那五個 Patch\r\n\r\n```shell\r\nlab@AI:~/Downloads/linux$ git checkout v6.16-baseline\r\nAlready on 'v6.16-baseline'\r\nlab@AI:~/Downloads/linux$ git log --oneline | grep 0cbef96\r\nlab@AI:~/Downloads/linux$ git log --oneline | grep aa7a927\r\nlab@AI:~/Downloads/linux$ git log --oneline | grep 443046d\r\nlab@AI:~/Downloads/linux$ git log --oneline | grep ed18738\r\nlab@AI:~/Downloads/linux$ git log --oneline | grep 0679963\r\ndfa106799639 [ARM] pxa: cleanup the coding style of pxa_gpio_set_type()\r\nlab@AI:~/Downloads/linux$ \r\n```\r\n\r\n\r\n\r\n### 建立實驗組\r\n\r\n```shell\r\ncd ~/Downloads/linux\r\ngit checkout master\r\n\r\n# 以第五個補丁的 commit 為基礎，建立我們最終的實驗分支\r\ngit checkout -b v6.16-patched-all-5 06799631d522\r\n\r\n# 1. 建立並修正設定檔\r\ncp /boot/config-$(uname -r) .config\r\nsed -i 's/CONFIG_SYSTEM_TRUSTED_KEYS/#CONFIG_SYSTEM_TRUSTED_KEYS/g' .config\r\nmake olddefconfig\r\n\r\n# 2. 編譯 (請密切注意這裡是否會報錯)\r\nmake -j$(nproc)\r\n\r\n# 3. 如果編譯成功，才執行安裝\r\nsudo make modules_install\r\nsudo make install\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 4.3 實驗結果\r\n\r\n\r\n### 對照組\r\n\r\n我們重複本文第一次 Perfetto 和 pm-graph 的實驗方法，觀察 `suspend_enter` 階段的耗時是 14 ms 352 us 。\r\n![image](https://hackmd.io/_uploads/SJZRmmrulg.png)\r\n\r\n\r\n\r\n\r\n### 實驗組\r\n\r\n\r\n我們重複本文第一次 Perfetto 和 pm-graph 的實驗方法，觀察 `suspend_enter` 階段的耗時是 13 ms 444 us 。\r\n![image](https://hackmd.io/_uploads/r1JPWtBOel.png)\r\n\r\n\r\n# 參考資料\r\n[1] [System Sleep States — The Linux Kernel  documentation](https://docs.kernel.org/admin-guide/pm/sleep-states.html)\r\n[2] [System Suspend Code Flows — The Linux Kernel  documentation](https://docs.kernel.org/admin-guide/pm/suspend-flows.html)\r\n[3] [Linux Suspend/Resume 實驗（一）](https://hackmd.io/@Guanchun0803/SuspendResume#)\r\n[4] [Linux Commit History: rafaeljw](https://github.com/torvalds/linux/commits/master/?author=rafaeljw)\r\n",
    "date": "2025-08-19T07:42:39.937Z",
    "category": "General",
    "readTime": "17 min read",
    "published": true,
    "author": "Yu-Sheng Tzou",
    "image": null
  },
  {
    "id": 1755589044128,
    "title": "探討特徵提取與匹配",
    "slug": "",
    "excerpt": "---\r\ntitle: 探討特徵提取與匹配\r\n\r\n---\r\n\r\n# 探討特徵提取與匹配\r\n\r\n\r\n# 1. 前言\r\n特徵提取與匹配在二維電腦視覺和三維電腦視覺都有廣泛的應用，從靜態影像拼接、相機校正到三維模型重建等。\r\n\r\n本文將逐一講解特徵提取的演算法，從經典的 SIFT (Scale Invar...",
    "content": "---\r\ntitle: 探討特徵提取與匹配\r\n\r\n---\r\n\r\n# 探討特徵提取與匹配\r\n\r\n\r\n# 1. 前言\r\n特徵提取與匹配在二維電腦視覺和三維電腦視覺都有廣泛的應用，從靜態影像拼接、相機校正到三維模型重建等。\r\n\r\n本文將逐一講解特徵提取的演算法，從經典的 SIFT (Scale Invariant Feature Transform)，到基於其衍生的 DSP-SIFT (Domain-Size Pooling Scale Invariant Feature Transform)，和近期基於深度學習網路的 SuperPoint 等。\r\n\r\n最後，我們會做實驗去比較、分析和評估這三種演算法的特性、優缺點，希望藉此更理解他們的理論基礎以及應用場景的差異。\r\n\r\n\r\n\r\n# 2. 理論\r\n\r\n## 2.1 SIFT (Scale Invariant Feature Transform)\r\n\r\n此演算法會將一張影像轉換成一個大的局部特徵向量 (local feature vectors) 的集合，每一個局部特徵向量會不變，即使在影像平移 (translation), 縮放 (scaling) 和旋轉 (rotation), 以及部份不變在光照改變的情況下。\r\n\r\n在尺度空間中（在 2.1.1 會介紹），透過尋找高斯差分（Difference-of-Gaussian）函數的極大值或極小值位置（在 2.1.1 後面會介紹），來識別關鍵位置。每個關鍵點都會用來產生一個特徵向量，用於描述依照其尺度空間座標系取樣的局部影像區域。這些特徵透過對影像梯度位置進行模糊處理，達成對局部變化（例如仿射變換或三維投影）的部分不變性。此方法是基於哺乳類視覺皮層中複雜細胞（complex cells）行為的模型所設計。最終得到的特徵向量稱為 SIFT 關鍵點（SIFT keys）。在目前的實作中，每張影像會產生約 1000 個 SIFT 關鍵點，而整個過程的計算時間少於 1 秒。\r\n\r\n![image](https://hackmd.io/_uploads/HkcCPhKdll.png)\r\n\r\n### 2.1.1 尺度空間的建立 (Construction of Scale-Space)\r\n\r\n#### 高斯影像金字塔的生成\r\n\r\n以白話來說，可以假設現在我們有一張對台北市仁愛圓環的空拍圖，現在我們先對它做高斯模糊，並得到在這個影像尺寸下的從清晰到越來越模糊的一疊影像，越模糊的放在越上面。現在我們複製那疊影像裡面中度模糊的影像然後做尺寸上的縮小，當作是影像金字塔的往上面新的一層的底，然後重複剛才高斯模糊的操作在該層得到另一疊影像。經過數次這樣的操作後，按照時間先後順序，越近期得到的那疊影像，放在越上面，我們就得到所謂的高斯影像金字塔。\r\n\r\n以實做細節上來說，由於二維高斯函數（2D Gaussian function）是可分離的，因此將其與輸入影像進行卷積時，可以先在水平方向、再在垂直方向各進行一次一維高斯函數（1D Gaussian function）的運算，就能高效地完成計算。在關鍵點定位（key localization）過程中，所有的平滑（smoothing）運算都採用 $\\sigma = \\sqrt{2}$ 。這個運算可以用一個包含 7 個取樣點的一維濾波器（1D kernel）來近似，並且能達到足夠的精確度。\r\n\r\n![image](https://hackmd.io/_uploads/B1-XsiYOll.png)\r\n\r\n在這裡，輸入影像首先使用高斯函數以 $\\sigma = \\sqrt{2}$ 進行卷積，得到影像 \\(A\\)。接著，再以相同的 $\\sigma = \\sqrt{2}$ 進行一次增量平滑，得到新的影像 \\(B\\)，此時影像 \\(B\\) 的有效平滑尺度為 $\\sigma = {2}$。\r\n\r\n為了產生下一層金字塔（pyramid）影像，此方法利用雙線性插值（bilinear interpolation）對已經平滑過的影像 \\(B\\) 進行重取樣（resample），在每個方向上的像素間距為 1.5。  雖然看起來用比例 $\\sqrt{2}$ 進行重取樣會比較自然，但唯一的限制是取樣必須夠密，才能偵測到極大值與極小值。1.5 的間距表示每個新像素都是原本相鄰 4 個像素的線性組合，這樣的做法計算效率高，且能最小化重取樣系數變動所帶來的混疊（aliasing）現象。\r\n\r\n![image](https://hackmd.io/_uploads/BkLqBEoull.png)\r\n\r\n\r\n#### 高斯差分影像金字塔 (DoG) 的生成\r\n\r\n我們為了要得到 DoG 影像金字塔，我們將該層的底部的影像和它上面一層的影像相減，得到一張 DoG 影像，然後在它上面一層的影像又和它上上面一層的影像相減，得到第二張 DoG 影像。以此類推，對於高斯影像金字塔的每一層都做一樣的操作，我們可以得到 DoG 影像金字塔。\r\n\r\n高斯差分函數（Difference of Gaussian, DoG）也就是是透過用影像 \\(A\\) 減去影像 \\(B\\) 來得到，這兩個高斯的比例為 $(2/\\sqrt{2} = \\sqrt{2})$。\r\n\r\n\r\n![image](https://hackmd.io/_uploads/H1VsH4ouxe.png)\r\n\r\n\r\n\r\n### 2.1.2 關鍵點定位與篩選 (Keypoint Localization and Filtering)\r\n\r\n尺度空間函數的極大值與極小值，是透過比較 DoG 影像金字塔中每個像素與其鄰居來決定的。  首先，每個像素會和該 DoG 影像金字塔層級內的 8 個鄰居做比較，如果該像素在這層是極大值或極小值，接著會計算在下一個較低層（解析度較高）中對應的像素位置，考慮到 1.5 倍的重取樣比例。  如果該像素在較低層依然比該位置像素和其 8 個鄰居更大（或更小），則會進一步向上一層重複此測試。由於大部分像素會在幾次比較後被淘汰，因此這個偵測過程的計算成本很低，比建立 DoG 影像金字塔的計算量小得多。\r\n\r\n若 DoG 影像金字塔的第一層取樣率和輸入影像相同，最高頻率訊號將會被忽略。這是因為初始的平滑步驟會使得訊號峰值分離，確保偵測的穩健性。因此，我們會先將輸入影像使用雙線性插值放大 2 倍，然後再建構 DoG 影像金字塔。這樣做後，一張典型的 512×512 像素影像大約能產生 1000 個關鍵點，相較於沒有放大時只有四分之一的數量。\r\n\r\n\r\n\r\n\r\n\r\n\r\n### 2.1.3 關鍵點穩定性\r\n\r\n為了在每個關鍵點描述影像，金字塔每一層的平滑影像 \\(A\\) 會被用來提取影像梯度和方向。在每個像素 $A_{ij}$ 上，利用像素差分計算影像梯度的大小 $M_{ij}$ 和方向 $R_{ij}$：\r\n\r\n![image](https://hackmd.io/_uploads/BJ_aZ3Kdee.png)\r\n\r\n像素差分計算效率很高，並且由於先前已經進行了大量平滑，其精確度也足夠。在確定關鍵點位置時，會補償有效的半像素偏移。\r\n\r\n對光照變化的魯棒性透過對梯度大小進行閾值處理來增強，閾值設定為最大可能梯度值的 0.1 倍。這可以減少光照方向變化對具有 3D 凹凸表面的影響，因為光照改變可能會導致梯度大小發生很大變化，但對梯度方向的影響相對較小。\r\n\r\n每個關鍵點會被分配一個標準方向，使得影像描述符對旋轉保持不變。為了使其對光照或對比度變化盡可能穩定，方向是透過局部影像梯度方向的直方圖峰值來決定的。方向直方圖是使用高斯加權窗口建立的，其標準差為當前平滑尺度的 3 倍。\r\n\r\n這些權重會與閾值化後的梯度值相乘，並累加到對應方向 $R_{ij}$ 的直方圖中。直方圖共有 36 個區間，覆蓋 360 度的旋轉範圍，並在選擇峰值前進行平滑處理。\r\n\r\n可以通過對自然影像施加仿射投影、對比度與亮度變化，以及加入噪聲，來測試所得到的關鍵點的穩定性。對第一張影像中檢測到的每個關鍵點，其在變換後影像中的位置可以根據變換參數進行預測。這個框架被用來選擇上述各種採樣和平滑參數，以在保持穩定性的同時獲得最佳效率。\r\n\r\n圖 1 顯示了在 2 個倍頻範圍內僅對較大尺度檢測到的相對少量關鍵點（以避免過度擁擠）。每個關鍵點用一個方框表示，從中心到方框一邊的線表示方向。在圖的後半部分，影像旋轉了 15 度，縮放因子為 0.9，水平方向拉伸 1.1 倍。像素強度範圍在 0 到 1 之間，亮度減去 0.1，對比度乘以 0.9。隨後加入隨機像素噪聲，使信號小於 5 bits/像素。儘管經過這些變換，第一張影像中 78% 的關鍵點在第二張影像中仍能在預測位置、尺度和方向上找到相匹配的關鍵點。\r\n\r\n![image](https://hackmd.io/_uploads/HJPacsYdgx.png)\r\n\r\n### 2.1.4 局部影像描述子 (Local image description)\r\n\r\n給定每個關鍵點的穩定**位置、尺度和方向**後，就可以以一種對這些變換不變的方式來描述該區域的局部影像。此外，還希望這種表示方式對局部幾何形狀的小偏移具有魯棒性，例如仿射變換或 3D 投影所造成的變化。\r\n\r\n其中一種方法來自於視覺皮層複雜神經元（complex neurons）的反應特性：\r\n**在保持方向和空間頻率專一性的同時，允許特徵位置在一個小範圍內變化**。 Edelman, Intrator 和 Poggio [5] 進行的實驗模擬了複雜神經元對不同 3D 視角的電腦圖形模型的反應，發現複雜細胞的輸出在區分能力上明顯優於基於簡單相關性的匹配。這可以用一個例子來說明：**若仿射投影在某一方向上對影像進行了拉伸，則梯度特徵的相對位置會改變，但對它們的方向和空間頻率影響較小。**\r\n\r\n這種對局部幾何失真的魯棒性可以透過用多張分別表示不同方向的影像（稱為方向平面）來描述局部影像區域而獲得。每個方向平面僅包含對應該方向的梯度，對於中間方向則使用線性插值。每個方向平面會進行模糊處理（blurring）和重新取樣，以允許梯度位置有較大的偏移。\r\n\r\n這種方法可以高效實作，因為可以直接重用在高斯影像金字塔每一層為方向選擇所預先計算好的梯度與方向資訊。對於每個關鍵點，作者使用其被檢測到所在高斯影像金字塔層的像素取樣。在關鍵點位置周圍半徑 8 像素的圓內的像素，會被插入到對應的方向平面中。方向的計算是相對於關鍵點方向進行的，方法是用像素的梯度方向減去關鍵點的方向。\r\n\r\n在實驗中，作者使用了 8 個方向平面，每個平面在 4×4 的位置網格上進行取樣，取樣間距是梯度檢測時像素間距的 4 倍。模糊處理是透過將每個像素的梯度分配給其在取樣網格中的 8 個最近鄰點，並在方向與兩個空間維度上進行線性插值來完成的。這種實現方式比顯式進行模糊與重新取樣要高效得多，但效果幾乎相同。\r\n\r\n為了在更大尺度下取樣，這一過程會在高斯影像金字塔高一個八度的第二層重複一次。不過，這一次採用的是 2×2 的取樣區域，而不是 4×4，這樣在兩個尺度下觀察到的影像區域就大致相同，因此附近的遮擋不會對某一個尺度產生更大影響。因此，SIFT 關鍵點向量中來自兩個尺度的總取樣數為：8×4×4+8×2×2=160，也就產生了一個 160 維的向量，這提供了足夠多的測量值來保證高度的區分能力。\r\n\r\n\r\n## 2.2 DSP-SIFT (Domain-Size Pooling - Scale Invariant Feature Transform)\r\n\r\n![image](https://hackmd.io/_uploads/ByB1O7iOxe.png)\r\n\r\n![image](https://hackmd.io/_uploads/SkUYVViugl.png)\r\n\r\n（待補）\r\n\r\n\r\n## 2.3 SuperPoint\r\n\r\nSuperPoint 基於深度學習的方法在一張影像上尋找關鍵點 keypoints (interesting points)。它使用一個 downsized map (W/8 and H/8) 的張量 65 channels 來編碼關鍵點，而不是使用 deconvolution layers 和一個原始影像大小的 binary mask 來表示關鍵點。\r\n\r\n![image](https://hackmd.io/_uploads/BkyBEtKdex.png)\r\n\r\n（待補）\r\n\r\n\r\n# 3. 實驗與結果\r\n\r\n我們將做實驗去比較、分析和評估這三種演算法的特性、優缺點。希望藉此更理解他們的理論基礎以及應用場景的差異。\r\n\r\n（待補）\r\n\r\n# 參考文獻\r\n[1] D. G. Lowe, \"Object recognition from local scale-invariant features,\" in Proc. 7th IEEE Int. Conf. Computer Vision, vol. 2, Kerkyra, Greece, 1999, pp. 1150–1157.  \r\n[2] J. Dong and S. Soatto, \"Domain-size pooling in local descriptors: DSP-SIFT,\" in Proc. IEEE Conf. Computer Vision and Pattern Recognition, Boston, MA, USA, 2015, pp. 5097–5106.  \r\n[3] D. DeTone, T. Malisiewicz, and A. Rabinovich, \"Superpoint: Self-supervised interest point detection and description,\" in Proc. IEEE Conf. Computer Vision and Pattern Recognition Workshops, Salt Lake City, UT, USA, 2018, pp. 224–236.\r\n",
    "date": "2025-08-19T07:37:24.128Z",
    "category": "Research",
    "readTime": "2 min read",
    "published": true,
    "author": "Yu-Sheng Tzou",
    "image": null
  }
]